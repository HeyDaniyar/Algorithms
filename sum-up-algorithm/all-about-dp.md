# dp

Dynamic Programming，动态规划，估计是整个算法题里最有难度却又最好玩的题型。动态规划的核心就是在于找到动态规划方程，按我的理解就是发现一个问题是否可以从子问题中找到答案，比如说让你求第N个解，那我们去看看第N-1个问题或者n-2个问题和第n个问题有什么关系。一般来说，像类似 `求第N个元素`，值，和，最大值，返回最大路径，返回所有组合，返回所有解都可以用dp或者递归的思想。

关于递归和动态规划的区别，在我看来就是很简单的一个标志，动态规划存储子问题的结果，然而递归不存储。

一些常利用到的dp思想有：

- `divide and conquer` 分而治之的思想，即将问题分成几个部分，每一部分相互独立，互不重叠，假定每一部分都可以用递归解决，最后去合并结果。最典型的应该就是快排和合并排序。

- `Greedy Algorithm`, 贪婪算法，即只做当下的最优判断，并且以此为基础进行下一步计算。

- `backtracking`,即回溯，深度搜索直到空间的尽头。


## 例题分析


> `leetcode` 70： 爬梯子问题

也许是最经典最简单的dp问题，每次只能前进一台阶或者两台阶，那请问有多少种方法爬到有N个台阶的楼梯上？  

我们从最后开始分析，爬到第N个台阶只有两种可能，要不是从倒数第二个梯子直接前进两个台阶上来的，要不就是倒数第一个梯子上前进一步上来的，所以方程很好完成，那就是

`dp[N] = dp[oneStepBefore] + dp[twoStepBefore] `

这里的one_step_before指的是离终点还有一步的点有多少方法， two_step_before还有两部的点，就拿n=3举例，就可以想到。
得到了动态规范方程，代码也就很简单了。

> 'leetcode' 139: Word Break问题：给定一个字符串和字典，判断字符串能否由字典的单词构成

如果考虑前n个字符，对于在`[0,N]`之间的第i个字符，那么对于`s.substring(0，i)`这个`[0,i]`的前驱节点来说，我们可以直接通过读取`dp[i]`知道是否可以用字典表示，对与`[i,n]`我们再去看看字典中是否存在，如此一来就可以知道`dp[n]`的结果。所以只要写一个两层循环即可得到答案，外层循环从`string`的第一个字符开始遍历，内层循环每次从0开始遍历。

`dp[n] = dp[i] && dict.includes[s.substring(i,n)] (0 < i < n)`;


> 'leetcode 62' 机器人路线问题：一个机器人只能向右或者向下，到达m*n点的所有路径

一个机器人能到达m*n点的所有路径dp[m,n]无非就是dp[m-1,n]+ dp[m,n-1]。我们可以预设第一行和第一列都为1；因为到达那些点只有一种方法。然后我们在用我们提到的公式。（还可以优活成一维数组，但现在不太理解）
